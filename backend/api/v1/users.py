"""
api/v1/users.py — v1 authentication endpoints.

Endpoints:
    POST /api/v1/auth/register — create a new user account
    POST /api/v1/auth/login    — authenticate with email + password, start a session
    POST /api/v1/auth/logout   — invalidate the current session
    GET  /api/v1/auth/me       — return the current authenticated user
"""

import logging
import secrets

from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from ninja import Router
from ninja.security import django_auth
from ninja.errors import HttpError

from users.models import CustomUser
from users.validators import validate_email_format
from schemas.users import LoginIn, RegisterIn, UserOut, MessageOut

logger = logging.getLogger(__name__)

router = Router(tags=['Auth'])


# ── Endpoints ─────────────────────────────────────────────────────────────────

@router.post('/auth/register', response=UserOut)
def auth_register(request, payload: RegisterIn):
    """Creates a new user account and starts a session.

    The username is autogenerated from the email local part. If the local
    part is already taken, a short random suffix is appended (e.g. john_a1b2).
    The email is normalised to lowercase before storage and uniqueness checks.

    Args:
        request: The HTTP request object.
        payload: Registration fields including email, password, and
            confirm_password.

    Returns:
        A UserOut representing the newly created and logged-in user.

    Raises:
        HttpError: 400 if validation fails or the email is already registered.
    """
    if email_error := validate_email_format(payload.email):
        raise HttpError(400, email_error)

    email = payload.email.lower()

    if payload.password != payload.confirm_password:
        raise HttpError(400, 'Passwords do not match.')

    # Construct an unsaved user so UserAttributeSimilarityValidator can
    # compare the password against the user's attributes (email, name, etc.).
    unsaved_user = CustomUser(
        email=email,
        first_name=payload.first_name,
        last_name=payload.last_name,
    )
    try:
        validate_password(payload.password, user=unsaved_user)
    except ValidationError as e:
        raise HttpError(400, ' '.join(e.messages))

    if CustomUser.objects.filter(email=email).exists():
        raise HttpError(400, 'An account with this email already exists.')

    username = _generate_username_from_email(email)

    try:
        user = CustomUser.objects.create_user(
            username=username,
            email=email,
            password=payload.password,
            first_name=payload.first_name,
            last_name=payload.last_name,
        )
    except IntegrityError:
        # A concurrent request created the same email or username between
        # our uniqueness check and the insert. Treat as a duplicate email
        # since that is the most likely cause.
        raise HttpError(400, 'An account with this email already exists.')

    login(request, user)
    logger.info(f'New user registered: {user.username} ({user.email}).')

    return _serialize_user(user)


@router.post('/auth/login', response=UserOut)
def auth_login(request, payload: LoginIn):
    """Authenticates a user by email and password and starts a session.

    The email is normalised to lowercase before lookup. Django's
    authenticate() expects a username, so the username is resolved
    from the provided email before authentication is attempted.

    Args:
        request: The HTTP request object.
        payload: Login credentials containing email and password.

    Returns:
        A UserOut representing the authenticated user.

    Raises:
        HttpError: 401 if the email is not found or the password is incorrect.
    """
    email = payload.email.lower()

    try:
        user = CustomUser.objects.get(email=email)
    except CustomUser.DoesNotExist:
        raise HttpError(401, 'Invalid email or password.')
    except CustomUser.MultipleObjectsReturned:
        # Should not occur once the unique constraint is in place, but
        # handled defensively for any pre-existing duplicate rows.
        logger.error(f'Multiple users found for email: {email}')
        raise HttpError(401, 'Invalid email or password.')

    authenticated_user = authenticate(
        request,
        username=user.username,
        password=payload.password,
    )

    if authenticated_user is None:
        raise HttpError(401, 'Invalid email or password.')

    login(request, authenticated_user)
    logger.info(f'User {authenticated_user.username} logged in.')

    return _serialize_user(
        CustomUser.objects.prefetch_related('households').get(pk=authenticated_user.pk)
    )


@router.post('/auth/logout', auth=django_auth, response=MessageOut)
def auth_logout(request):
    """Invalidates the current session.

    Args:
        request: The HTTP request object. Must be authenticated.

    Returns:
        A MessageOut confirming the user has been logged out.
    """
    logger.info(f'User {request.user.username} logged out.')
    logout(request)
    return MessageOut(message='Logged out successfully.')


@router.get('/auth/me', auth=django_auth, response=UserOut)
def auth_me(request):
    """Returns the currently authenticated user.

    Called on page load to check whether a valid session already exists.

    Args:
        request: The HTTP request object. Must be authenticated.

    Returns:
        A UserOut representing the current user.
    """
    user = CustomUser.objects.prefetch_related('households').get(pk=request.user.pk)
    return _serialize_user(user)


# ── Helpers ───────────────────────────────────────────────────────────────────

def _generate_username_from_email(email: str) -> str:
    """Derives a unique username from the local part of an email address.

    Assumes the email has already been validated and normalised to lowercase.
    The local part is truncated to 141 characters before any suffix is added
    to ensure the final username never exceeds Django's 150-character limit.

    If the local part is already taken, a 4-character random hex suffix is
    appended and retried up to 10 times before falling back to an 8-character
    suffix.

    Examples:
        john@gmail.com  → 'john'
        john@yahoo.com  → 'john_a1b2'  (if 'john' is already taken)

    Args:
        email: A validated, lowercased email address. Must contain an '@'
            symbol — callers are responsible for validating the email before
            passing it to this function.

    Returns:
        A unique username string derived from the email local part.
    """
    local = email.split('@')[0][:141]

    if not CustomUser.objects.filter(username=local).exists():
        return local

    for _ in range(10):
        candidate = f"{local}_{secrets.token_hex(2)}"
        if not CustomUser.objects.filter(username=candidate).exists():
            return candidate

    return f"{local}_{secrets.token_hex(4)}"


def _serialize_user(user: CustomUser) -> dict:
    """Serializes a CustomUser instance into a dict matching UserOut.

    Assumes households have already been prefetched on the queryset to
    avoid N+1 queries. At registration, the households list will be empty.

    Args:
        user: The CustomUser instance to serialize.

    Returns:
        A dict with user fields and a list of associated households.
    """
    return {
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'first_name': user.first_name,
        'last_name': user.last_name,
        'households': [
            {'id': h.id, 'name': h.name}
            for h in user.households.all()
        ],
    }
