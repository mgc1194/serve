import pytest

from ninja.testing import TestClient
from ninja.main import NinjaAPI

from users.api import api
from users.models import CustomUser


# ── Fixtures ──────────────────────────────────────────────────────────────────

@pytest.fixture(autouse=True)
def reset_ninja_registry():
    """Clear Ninja API registry before each test to avoid conflicts."""
    yield
    if 'users' in NinjaAPI._registry:
        NinjaAPI._registry.remove('users')


@pytest.fixture
def client():
    return TestClient(api)


@pytest.fixture
def valid_payload():
    """A registration payload that passes all validations."""
    return {
        'email': 'john@example.com',
        'password': 'Secure@Password1!',
        'confirm_password': 'Secure@Password1!',
        'first_name': 'John',
        'last_name': 'Doe',
    }


@pytest.fixture
def registered_user(db, valid_payload):
    """A pre-existing user in the database."""
    return CustomUser.objects.create_user(
        username='john',
        email=valid_payload['email'],
        password=valid_payload['password'],
    )


# ── POST /api/auth/register ───────────────────────────────────────────────────

@pytest.mark.django_db
class TestAuthRegister:

    @pytest.fixture(autouse=True)
    def mock_login(self, mocker):
        """Patch Django's login() to avoid session handling in tests."""
        return mocker.patch('users.api.login')

    def test_successful_registration_returns_user(self, client, valid_payload):
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 200
        data = response.json()
        assert data['email'] == valid_payload['email']
        assert data['first_name'] == 'John'
        assert data['last_name'] == 'Doe'
        assert data['households'] == []

    def test_username_autogenerated_from_email_local_part(self, client, valid_payload):
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 200
        assert response.json()['username'] == 'john'

    def test_username_gets_suffix_when_local_part_taken(self, client, valid_payload, registered_user):
        new_payload = valid_payload.copy()
        new_payload['email'] = 'john@otherdomain.com'
        response = client.post('/auth/register', json=new_payload)
        assert response.status_code == 200
        username = response.json()['username']
        assert username.startswith('john_')
        assert len(username) > len('john_')

    def test_duplicate_email_returns_400(self, client, valid_payload, registered_user):
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400
        assert 'email already exists' in response.json()['detail'].lower()

    def test_invalid_email_format_returns_400(self, client, valid_payload):
        valid_payload['email'] = 'notanemail'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_mismatched_passwords_returns_400(self, client, valid_payload):
        valid_payload['confirm_password'] = 'DifferentPassword1!'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400
        assert 'do not match' in response.json()['detail'].lower()

    def test_weak_password_too_short_returns_400(self, client, valid_payload):
        valid_payload['password'] = 'Short1!'
        valid_payload['confirm_password'] = 'Short1!'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_weak_password_no_uppercase_returns_400(self, client, valid_payload):
        valid_payload['password'] = 'nouppercase1234!'
        valid_payload['confirm_password'] = 'nouppercase1234!'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_weak_password_no_lowercase_returns_400(self, client, valid_payload):
        valid_payload['password'] = 'NOLOWERCASE1234!'
        valid_payload['confirm_password'] = 'NOLOWERCASE1234!'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_weak_password_no_digit_returns_400(self, client, valid_payload):
        valid_payload['password'] = 'NoDigitsHere!!!'
        valid_payload['confirm_password'] = 'NoDigitsHere!!!'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_weak_password_no_special_char_returns_400(self, client, valid_payload):
        valid_payload['password'] = 'NoSpecialChar1234'
        valid_payload['confirm_password'] = 'NoSpecialChar1234'
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 400

    def test_optional_name_fields_default_to_empty(self, client, valid_payload):
        del valid_payload['first_name']
        del valid_payload['last_name']
        response = client.post('/auth/register', json=valid_payload)
        assert response.status_code == 200
        data = response.json()
        assert data['first_name'] == ''
        assert data['last_name'] == ''

    def test_user_is_created_in_database(self, client, valid_payload):
        client.post('/auth/register', json=valid_payload)
        assert CustomUser.objects.filter(email=valid_payload['email']).exists()


# ── POST /api/auth/login ──────────────────────────────────────────────────────

@pytest.mark.django_db
class TestAuthLogin:

    @pytest.fixture(autouse=True)
    def mock_login(self, mocker):
        """Patch Django's login() to avoid session handling in tests."""
        return mocker.patch('users.api.login')

    def test_successful_login_returns_user(self, client, valid_payload, registered_user):
        response = client.post('/auth/login', json={
            'email': valid_payload['email'],
            'password': valid_payload['password'],
        })
        assert response.status_code == 200
        assert response.json()['email'] == valid_payload['email']

    def test_wrong_password_returns_401(self, client, registered_user, valid_payload):
        response = client.post('/auth/login', json={
            'email': valid_payload['email'],
            'password': 'WrongPassword1!',
        })
        assert response.status_code == 401

    def test_unknown_email_returns_401(self, client):
        response = client.post('/auth/login', json={
            'email': 'nobody@example.com',
            'password': 'SomePassword1!',
        })
        assert response.status_code == 401

    def test_error_message_does_not_distinguish_email_from_password(self, client, registered_user, valid_payload):
        """Ensures identical error messages for wrong email vs wrong password
        to prevent user enumeration attacks."""
        wrong_email_response = client.post('/auth/login', json={
            'email': 'nobody@example.com',
            'password': valid_payload['password'],
        })
        wrong_password_response = client.post('/auth/login', json={
            'email': valid_payload['email'],
            'password': 'WrongPassword1!',
        })
        assert wrong_email_response.json()['detail'] == wrong_password_response.json()['detail']


# ── POST /api/auth/logout ─────────────────────────────────────────────────────

@pytest.mark.django_db
class TestAuthLogout:

    def test_unauthenticated_logout_returns_401(self, client):
        response = client.post('/auth/logout')
        assert response.status_code == 401


# ── GET /api/auth/me ──────────────────────────────────────────────────────────

@pytest.mark.django_db
class TestAuthMe:

    def test_unauthenticated_me_returns_401(self, client):
        response = client.get('/auth/me')
        assert response.status_code == 401

    def test_authenticated_me_returns_user(self, client, registered_user):
        response = client.get('/auth/me', user=registered_user)
        assert response.status_code == 200
        assert response.json()['email'] == registered_user.email
