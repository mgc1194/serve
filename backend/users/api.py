"""
users/api.py — Authentication endpoints.

Endpoints:
    POST /api/auth/login   — authenticate with email + password, start a session
    POST /api/auth/logout  — invalidate the current session
    GET  /api/auth/me      — return the current authenticated user
"""

import logging
import secrets
from typing import List

from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from ninja import NinjaAPI, Schema
from ninja.security import django_auth
from ninja.errors import HttpError

from .models import CustomUser
from .validators import validate_email_format

logger = logging.getLogger(__name__)

api = NinjaAPI(urls_namespace='users')


# ── Schemas ───────────────────────────────────────────────────────────────────

class RegisterRequest(Schema):
    email: str
    password: str
    confirm_password: str
    first_name: str = ''
    last_name: str = ''


class LoginRequest(Schema):
    email: str
    password: str


class HouseholdSchema(Schema):
    id: int
    name: str


class UserSchema(Schema):
    id: int
    username: str
    email: str
    first_name: str
    last_name: str
    households: List[HouseholdSchema]


class MessageResponse(Schema):
    message: str


# ── Endpoints ─────────────────────────────────────────────────────────────────

@api.post('/auth/register', response=UserSchema)
def auth_register(request, payload: RegisterRequest):
    """Creates a new user account and starts a session.

    The username is autogenerated from the email local part. If the local
    part is already taken, a short random suffix is appended (e.g. john_a1b2).

    Args:
        request: The HTTP request object.
        payload: Registration fields including email, password, and
            confirm_password.

    Returns:
        A UserSchema representing the newly created and logged-in user.

    Raises:
        HttpError: 400 if passwords do not match or the email is already
            registered.
    """
    # Email format
    if email_error := validate_email_format(payload.email):
        raise HttpError(400, email_error)

    # Password confirmation
    if payload.password != payload.confirm_password:
        raise HttpError(400, 'Passwords do not match.')

    # Password strength — validate_password() runs all validators registered
    # in settings.AUTH_PASSWORD_VALIDATORS and collects every error at once.
    try:
        validate_password(payload.password)
    except ValidationError as e:
        raise HttpError(400, ' '.join(e.messages))

    # Email uniqueness
    if CustomUser.objects.filter(email=payload.email).exists():
        raise HttpError(400, 'An account with this email already exists.')

    username = _generate_username(payload.email)

    user = CustomUser.objects.create_user(
        username=username,
        email=payload.email,
        password=payload.password,
        first_name=payload.first_name,
        last_name=payload.last_name,
    )

    login(request, user)
    logger.info(f'New user registered: {user.username} ({user.email}).')

    return _serialize_user(user)


@api.post('/auth/login', response=UserSchema)
def auth_login(request, payload: LoginRequest):
    """
    Authenticate a user by email and password and start a session.

    Django's authenticate() expects a username, so we resolve the
    username from the provided email first.
    """
    try:
        user = CustomUser.objects.get(email=payload.email)
    except CustomUser.DoesNotExist:
        raise HttpError(401, 'Invalid email or password.')

    authenticated_user = authenticate(
        request,
        username=user.username,
        password=payload.password,
    )

    if authenticated_user is None:
        raise HttpError(401, 'Invalid email or password.')

    login(request, authenticated_user)
    logger.info(f'User {authenticated_user.username} logged in.')

    return _serialize_user(authenticated_user)


@api.post('/auth/logout', auth=django_auth, response=MessageResponse)
def auth_logout(request):
    """
    Invalidate the current session.
    """
    logger.info(f'User {request.user.username} logged out.')
    logout(request)
    return MessageResponse(message='Logged out successfully.')


@api.get('/auth/me', auth=django_auth, response=UserSchema)
def auth_me(request):
    """
    Return the currently authenticated user.
    Called on page load to check if a valid session already exists.
    """
    return _serialize_user(request.user)


# ── Helpers ───────────────────────────────────────────────────────────────────

def _generate_username(email: str) -> str:
    """Derives a unique username from the local part of an email address.

    If the local part is already taken, a 4-character random hex suffix is
    appended and retried up to 10 times. Falls back to an 8-character suffix
    if all attempts are exhausted.

    Examples:
        john@gmail.com  → 'john'
        john@yahoo.com  → 'john_a1b2'  (if 'john' is already taken)

    Args:
        email: The user's email address.

    Returns:
        A unique username string derived from the email local part.
    """
    local = email.split('@')[0]

    if not CustomUser.objects.filter(username=local).exists():
        return local

    for _ in range(10):
        candidate = f"{local}_{secrets.token_hex(2)}"
        if not CustomUser.objects.filter(username=candidate).exists():
            return candidate

    # Fallback: 8-character suffix, collision probability negligible.
    return f"{local}_{secrets.token_hex(4)}"


def _serialize_user(user: CustomUser) -> dict:
    """
    Serialize a CustomUser instance into a dict matching UserSchema.
    Fetches related households in a single query.
    """
    return {
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'first_name': user.first_name,
        'last_name': user.last_name,
        'households': [
            {'id': h.id, 'name': h.name}
            for h in user.households.all()
        ],
    }
